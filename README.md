<div align="center">

# Vigenere Cipher Hacker / Ğ’Ğ·Ğ»Ğ¾Ğ¼ ÑˆĞ¸Ñ„Ñ€Ğ° Ğ’Ğ¸Ğ¶ĞµĞ½ĞµÑ€Ğ°

âœ¨âœ¨â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”âœ¨âœ¨

<a href="https://git.io/typing-svg"><img src="https://readme-typing-svg.demolab.com?font=Lobster+Two&size=50&duration=6000&pause=1000&color=3B9600&center=true&vCenter=true&repeat=false&width=700&height=110&lines=%F0%9F%94%90+Vigen%C3%A8re+Cipher+Hacker+%F0%9F%94%90" alt="Vigenere Cipher Hacker - Cryptanalysis Tool" /></a>

![C++](https://img.shields.io/badge/C++-8A2BE2?style=for-the-badge&logo=c%2B%2B&logoColor=white&labelColor=6A0DAD&color=9B30FF)
![Cryptography](https://img.shields.io/badge/Cryptography-000000?style=for-the-badge&logo=key&logoColor=white)
[![C.C.](https://img.shields.io/badge/-C.C.-3B9600?style=for-the-badge&logo=star&logoColor=white&labelColor=0d1117)](https://github.com/C-C-C0de)

`vigenere-cipher-hacker` `cryptanalysis` `frequency-analysis` `classical-crypto` `security-tools` `cpp17` `algorithms`

âœ¨âœ¨â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”âœ¨âœ¨

![](https://github.com/C-C-C0de/C-C-C0de/blob/main/assets/Hacking-Vigener.gif?raw=true)

âœ¨âœ¨â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”âœ¨âœ¨

<a href="https://git.io/typing-svg">
  <img src="https://readme-typing-svg.demolab.com?font=Fira+Code&weight=600&size=50&duration=4000&pause=1000&color=3B9600&center=true&vCenter=true&width=1000&height=100&lines=%F0%9F%8F%97%EF%B8%8F+%D0%A6%D0%95%D0%9B%D0%AC+%D0%9F%D0%A0%D0%9E%D0%95%D0%9A%D0%A2%D0%90+%F0%9F%8F%97%EF%B8%8F" alt="Typing SVG" />
</a>

</div>
 
 ____

&emsp;&emsp;ĞĞ±ÑŠÑÑĞ½Ğ¸Ñ‚ÑŒ Ğ¸ Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¿Ğ¾Ğ»Ğ½Ñ‹Ğ¹ Ğ°Ğ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼ Ğ²Ğ·Ğ»Ğ¾Ğ¼Ğ° ÑˆĞ¸Ñ„Ñ€Ğ° Ğ’Ğ¸Ğ¶ĞµĞ½ĞµÑ€Ğ°, Ğ¿Ñ€ĞµĞ´Ğ¾ÑÑ‚Ğ°Ğ²Ğ¸Ğ² Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ:

> **1. Ğ¢ĞµĞ¾Ñ€ĞµÑ‚Ğ¸Ñ‡ĞµÑĞºÑƒÑ Ğ¾ÑĞ½Ğ¾Ğ²Ñƒ** â€” Ğ²Ğ²Ğ¾Ğ´Ğ½Ğ°Ñ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ, ĞºĞ°Ğº ÑĞ°Ğ¼ Ğ°Ğ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼ Ñ€Ğ°Ğ±Ğ¾Ğ°Ñ‚ĞµÑ‚ (Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ¾Ğ² ĞšĞ°Ğ·Ğ¸ÑĞºĞ¸ Ğ¸ Ñ‡Ğ°ÑÑ‚Ğ¾Ñ‚Ğ½Ğ¾Ğ³Ğ¾ Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ·Ğ°);

```cpp
Ğ”Ğ»Ñ Ğ±Ğ¾Ğ»ĞµĞµ Ğ¿Ğ¾Ğ´Ñ€Ğ¾Ğ±Ğ½Ğ¾Ğ¹ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ğ¸ Ğ¾Ğ±Ñ€Ğ°Ñ‰Ğ°Ğ¹Ñ‚ĞµÑÑŒ Ğº Ğ¸ÑÑ‚Ğ¾Ñ‡Ğ½Ğ¸ĞºĞ°Ğ¼. ĞœĞ¾Ñ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ° Ğ²Ğ²ĞµÑÑ‚Ğ¸ Ğ² Ğ´ĞµĞ»Ğ¾ Ğ¸ Ğ¿Ğ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ ĞºĞ¾Ğ´. 
```

> **2. ĞŸÑ€Ğ°ĞºÑ‚Ğ¸Ñ‡ĞµÑĞºÑƒÑ Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ** â€” Ñ€Ğ°Ğ±Ğ¾Ñ‡Ğ¸Ğ¹ Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞ¼ĞµĞ½Ñ‚ Ğ´Ğ»Ñ ĞºÑ€Ğ¸Ğ¿Ñ‚Ğ¾Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ·Ğ°; 

> **3. Ğ˜Ğ½Ñ‚ĞµĞ»Ğ»ĞµĞºÑ‚ÑƒĞ°Ğ»ÑŒĞ½ÑƒÑ Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ** â€” Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹ Ğ¾Ñ‚Ğ±Ğ¾Ñ€ Ğ½Ğ°Ğ¸Ğ±Ğ¾Ğ»ĞµĞµ Ğ¾ÑĞ¼Ñ‹ÑĞ»ĞµĞ½Ğ½Ñ‹Ñ… Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ğ¾Ğ².

<div align="center">

âœ¨âœ¨â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”âœ¨âœ¨

<a href="https://git.io/typing-svg"><img src="https://readme-typing-svg.demolab.com?font=Momo+Trust+Display&size=60&duration=6000&pause=1000&color=3B9600&center=true&vCenter=true&width=1000&height=110&lines=%F0%9F%8C%8D+%D0%9E%D0%9F%D0%98%D0%A1%D0%90%D0%9D%D0%98%D0%95+%F0%9F%8C%8D" alt="Typing SVG" /></a>



____

</div>

> &emsp;&emsp;***Ğ¨Ğ¸Ñ„Ñ€ Ğ’Ğ¸Ğ¶ĞµĞ½ĞµÑ€Ğ°*** â€” ÑÑ‚Ğ¾ Ğ¿Ğ¾Ğ»Ğ¸Ğ°Ğ»Ñ„Ğ°Ğ²Ğ¸Ñ‚Ğ½Ñ‹Ğ¹ Ğ¼ĞµÑ‚Ğ¾Ğ´ ÑˆĞ¸Ñ„Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ, Ğ¿Ñ€ĞµĞ´Ğ½Ğ°Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ½Ñ‹Ğ¹ Ğ´Ğ»Ñ Ğ·Ğ°Ñ‰Ğ¸Ñ‚Ñ‹ Ñ‚ĞµĞºÑÑ‚Ğ¾Ğ²Ñ‹Ñ… Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…. ĞĞ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼ Ğ±Ñ‹Ğ» ÑĞ¾Ğ·Ğ´Ğ°Ğ½ Ğ‘Ğ»ĞµĞ·Ğ¾Ğ¼ Ğ´Ğµ Ğ’Ğ¸Ğ¶ĞµĞ½ĞµÑ€Ğ¾Ğ¼ Ğ² XVI Ğ²ĞµĞºĞµ Ğ¸ Ğ¿Ñ€ĞµĞ´ÑÑ‚Ğ°Ğ²Ğ»ÑĞµÑ‚ ÑĞ¾Ğ±Ğ¾Ğ¹ ÑƒÑĞ»Ğ¾Ğ¶Ğ½Ñ‘Ğ½Ğ½ÑƒÑ Ğ¼Ğ¾Ğ´Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ñ ÑˆĞ¸Ñ„Ñ€Ğ° Ğ¦ĞµĞ·Ğ°Ñ€Ñ. ĞšĞ»ÑÑ‡ĞµĞ²Ñ‹Ğ¼ Ğ¿Ñ€ĞµĞ¸Ğ¼ÑƒÑ‰ĞµÑÑ‚Ğ²Ğ¾Ğ¼ Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ° ÑĞ²Ğ»ÑĞµÑ‚ÑÑ Ğ¿Ñ€Ğ¸Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğµ Ğ¿Ñ€Ğ¾Ğ¸Ğ·Ğ²Ğ¾Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ ĞºĞ»ÑÑ‡Ğ° Ğ² Ğ²Ğ¸Ğ´Ğµ ÑĞ»Ğ¾Ğ²Ğ° Ğ¸Ğ»Ğ¸ Ñ„Ñ€Ğ°Ğ·Ñ‹, Ñ‡Ñ‚Ğ¾ Ğ·Ğ½Ğ°Ñ‡Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ Ğ¿Ğ¾Ğ²Ñ‹ÑˆĞ°ĞµÑ‚ Ğ½Ğ°Ğ´Ñ‘Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ ÑˆĞ¸Ñ„Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğ¿Ğ¾ ÑÑ€Ğ°Ğ²Ğ½ĞµĞ½Ğ¸Ñ Ñ Ğ¼Ğ¾Ğ½Ğ¾Ğ°Ğ»Ñ„Ğ°Ğ²Ğ¸Ñ‚Ğ½Ñ‹Ğ¼Ğ¸ ÑĞ¸ÑÑ‚ĞµĞ¼Ğ°Ğ¼Ğ¸.

&emsp;&emsp;ĞŸÑ€Ğ¸Ğ½Ñ†Ğ¸Ğ¿ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ñ Ğ¾ÑĞ½Ğ¾Ğ²Ğ°Ğ½ Ğ½Ğ° Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğ¸ ĞºĞ»ÑÑ‡ĞµĞ²Ğ¾Ğ³Ğ¾ ÑĞ»Ğ¾Ğ²Ğ°, ĞºĞ¾Ñ‚Ğ¾Ñ€Ğ¾Ğµ Ñ†Ğ¸ĞºĞ»Ğ¸Ñ‡ĞµÑĞºĞ¸ Ğ¿Ğ¾Ğ²Ñ‚Ğ¾Ñ€ÑĞµÑ‚ÑÑ Ğ²Ğ´Ğ¾Ğ»ÑŒ Ğ²ÑĞµĞ³Ğ¾ Ñ‚ĞµĞºÑÑ‚Ğ°. ĞšĞ°Ğ¶Ğ´Ğ°Ñ Ğ±ÑƒĞºĞ²Ğ° Ğ¸ÑÑ…Ğ¾Ğ´Ğ½Ğ¾Ğ³Ğ¾ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ ÑĞ´Ğ²Ğ¸Ğ³Ğ°ĞµÑ‚ÑÑ Ğ½Ğ° Ğ²ĞµĞ»Ğ¸Ñ‡Ğ¸Ğ½Ñƒ, Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ÑĞµĞ¼ÑƒÑ ÑĞ¾Ğ¾Ñ‚Ğ²ĞµÑ‚ÑÑ‚Ğ²ÑƒÑÑ‰ĞµĞ¹ Ğ±ÑƒĞºĞ²Ğ¾Ğ¹ ĞºĞ»ÑÑ‡Ğ°, Ñ‡Ñ‚Ğ¾ Ğ¾Ğ±ĞµÑĞ¿ĞµÑ‡Ğ¸Ğ²Ğ°ĞµÑ‚ Ğ¿Ğ¾Ğ»Ğ¸Ğ°Ğ»Ñ„Ğ°Ğ²Ğ¸Ñ‚Ğ½Ğ¾ÑÑ‚ÑŒ Ğ¿Ğ¾Ğ´ÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ¸ Ğ¸ ÑƒÑÑ‚Ğ¾Ğ¹Ñ‡Ğ¸Ğ²Ğ¾ÑÑ‚ÑŒ Ğº Ñ‡Ğ°ÑÑ‚Ğ¾Ñ‚Ğ½Ğ¾Ğ¼Ñƒ Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ·Ñƒ.
____
> &emsp;&emsp;***Ğ’Ğ·Ğ»Ğ¾Ğ¼ ÑˆĞ¸Ñ„Ñ€Ğ° Ğ’Ğ¸Ğ¶ĞµĞ½ĞµÑ€Ğ°*** â€” ÑÑ‚Ğ¾ Ğ¿Ñ€Ğ¾Ñ†ĞµÑÑ ĞºÑ€Ğ¸Ğ¿Ñ‚Ğ¾Ğ°Ğ½Ğ°Ğ»Ğ¸Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¾Ğ³Ğ¾ Ğ²ÑĞºÑ€Ñ‹Ñ‚Ğ¸Ñ Ğ¿Ğ¾Ğ»Ğ¸Ğ°Ğ»Ñ„Ğ°Ğ²Ğ¸Ñ‚Ğ½Ğ¾Ğ³Ğ¾ ÑˆĞ¸Ñ„Ñ€Ğ° Ğ±ĞµĞ· Ğ·Ğ½Ğ°Ğ½Ğ¸Ñ ĞºĞ»ÑÑ‡Ğ°, Ğ¾ÑĞ½Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¹ Ğ½Ğ° Ğ²Ñ‹ÑĞ²Ğ»ĞµĞ½Ğ¸Ğ¸ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ñ… Ğ·Ğ°ĞºĞ¾Ğ½Ğ¾Ğ¼ĞµÑ€Ğ½Ğ¾ÑÑ‚ĞµĞ¹ Ğ² Ğ·Ğ°ÑˆĞ¸Ñ„Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ¾Ğ¼ Ñ‚ĞµĞºÑÑ‚Ğµ Ğ¸ Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ğ¸ Ğ´Ğ»Ğ¸Ğ½Ñ‹ ĞºĞ»ÑÑ‡ĞµĞ²Ğ¾Ğ³Ğ¾ ÑĞ»Ğ¾Ğ²Ğ° Ñ Ğ¿Ğ¾ÑĞ»ĞµĞ´ÑƒÑÑ‰Ğ¸Ğ¼ Ğ²Ğ¾ÑÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸ĞµĞ¼ Ğ¸ÑÑ…Ğ¾Ğ´Ğ½Ğ¾Ğ³Ğ¾ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ.

> &emsp;&emsp;Ğ”Ğ»Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹ ĞºĞ¾Ğ´Ğ°, Ğ² ÑÑ‚ĞµĞ½Ğ´Ğµ ĞµÑÑ‚ÑŒ txt Ñ„Ğ°Ğ¹Ğ» (``` ĞĞµÑĞºĞ¾Ğ»ÑŒĞºĞ¾ Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€Ğ¾Ğ².txt ```) Ñ Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€Ğ°Ğ¼Ğ¸ Ğ·Ğ°ÑˆĞ¸Ñ„Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¾Ğ³Ğ¾ Ñ‚ĞµĞºÑÑ‚Ğ° Ğ¸ ĞºĞ»ÑÑ‡Ğ°.


<div align="center">

âœ¨âœ¨â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”âœ¨âœ¨

<a href="https://git.io/typing-svg"><img src="https://readme-typing-svg.demolab.com?font=Momo+Trust+Display&size=60&duration=6000&pause=1000&color=3B9600&center=true&vCenter=true&width=1000&height=110&lines=%F0%9F%8F%97%EF%B8%8F+%D0%90%D0%A0%D0%A5%D0%98%D0%A2%D0%95%D0%9A%D0%A2%D0%A3%D0%A0%D0%90+%D0%9A%D0%9E%D0%94%D0%90+%F0%9F%8F%97%EF%B8%8F" alt="Typing SVG" /></a>

</div>

<div align="center">

## ğŸ“¦ ĞĞ¡ĞĞĞ’ĞĞ«Ğ• ĞœĞĞ”Ğ£Ğ›Ğ˜ Ğ¡Ğ˜Ğ¡Ğ¢Ğ•ĞœĞ«

</div>

&emsp;&emsp;ĞŸÑ€Ğ¾Ğ³Ñ€Ğ°Ğ¼Ğ¼Ğ° Ğ¿Ñ€ĞµĞ´ÑÑ‚Ğ°Ğ²Ğ»ÑĞµÑ‚ ÑĞ¾Ğ±Ğ¾Ğ¹ ĞºĞ¾Ğ¼Ğ¿Ğ»ĞµĞºÑĞ½ÑƒÑ ÑĞ¸ÑÑ‚ĞµĞ¼Ñƒ Ğ´Ğ»Ñ Ğ²Ğ·Ğ»Ğ¾Ğ¼Ğ° ÑˆĞ¸Ñ„Ñ€Ğ° Ğ’Ğ¸Ğ¶ĞµĞ½ĞµÑ€Ğ°, ÑĞ¾ÑÑ‚Ğ¾ÑÑ‰ÑƒÑ Ğ¸Ğ· Ğ½ĞµÑĞºĞ¾Ğ»ÑŒĞºĞ¸Ñ… Ğ²Ğ·Ğ°Ğ¸Ğ¼Ğ¾ÑĞ²ÑĞ·Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ¼Ğ¾Ğ´ÑƒĞ»ĞµĞ¹:

> ### 1. ğŸ§  ĞĞ•Ğ™Ğ ĞĞ¡Ğ•Ğ¢Ğ¬ TEXT TYPE PERCEPTRON

&emsp;&emsp;ĞœĞ½Ğ¾Ğ³Ğ¾ÑĞ»Ğ¾Ğ¹Ğ½Ñ‹Ğ¹ Ğ¿ĞµÑ€Ñ†ĞµĞ¿Ñ‚Ñ€Ğ¾Ğ½ Ğ´Ğ»Ñ Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ·Ğ° Ğ»Ğ¸Ğ½Ğ³Ğ²Ğ¸ÑÑ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ñ… Ğ¾ÑĞ¾Ğ±ĞµĞ½Ğ½Ğ¾ÑÑ‚ĞµĞ¹ Ñ‚ĞµĞºÑÑ‚Ğ°. ĞšĞ»Ğ°ÑÑ Ğ²ĞºĞ»ÑÑ‡Ğ°ĞµÑ‚:

&emsp;&emsp;**â€¢ Ğ’ĞµÑĞ¾Ğ²Ñ‹Ğµ ĞºĞ¾ÑÑ„Ñ„Ğ¸Ñ†Ğ¸ĞµĞ½Ñ‚Ñ‹** - 10 Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ğ¾Ğ² Ğ´Ğ»Ñ Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ·Ğ° Ñ€Ğ°Ğ·Ğ»Ğ¸Ñ‡Ğ½Ñ‹Ñ… Ğ»Ğ¸Ğ½Ğ³Ğ²Ğ¸ÑÑ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ñ… Ğ¿Ñ€Ğ¸Ğ·Ğ½Ğ°ĞºĞ¾Ğ²;

&emsp;&emsp;**â€¢ Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ğ¸ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ°Ñ†Ğ¸Ğ¸** - ÑĞ¸Ğ³Ğ¼Ğ¾Ğ¸Ğ´Ğ° Ğ¸ ĞµĞµ Ğ¿Ñ€Ğ¾Ğ¸Ğ·Ğ²Ğ¾Ğ´Ğ½Ğ°Ñ Ğ´Ğ»Ñ Ğ¾Ğ±ÑƒÑ‡ĞµĞ½Ğ¸Ñ;

&emsp;&emsp;**â€¢ Ğ˜Ğ·Ğ²Ğ»ĞµÑ‡ĞµĞ½Ğ¸Ğµ Ğ¿Ñ€Ğ¸Ğ·Ğ½Ğ°ĞºĞ¾Ğ²** - Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ· Ñ‚Ñ€Ğ¸Ğ³Ñ€Ğ°Ğ¼Ğ¼, Ñ‡Ğ°ÑÑ‚Ğ¾Ñ‚Ğ½Ğ¾ÑÑ‚Ğ¸ Ğ±ÑƒĞºĞ², ÑĞ¾Ğ¾Ñ‚Ğ½Ğ¾ÑˆĞµĞ½Ğ¸Ñ Ğ³Ğ»Ğ°ÑĞ½Ñ‹Ñ…/ÑĞ¾Ğ³Ğ»Ğ°ÑĞ½Ñ‹Ñ…;

&emsp;&emsp;**â€¢ ĞœĞµÑ…Ğ°Ğ½Ğ¸Ğ·Ğ¼ Ğ¾Ğ±ÑƒÑ‡ĞµĞ½Ğ¸Ñ** - Ğ¼ĞµÑ‚Ğ¾Ğ´ Ğ¾Ğ±Ñ€Ğ°Ñ‚Ğ½Ğ¾Ğ³Ğ¾ Ñ€Ğ°ÑĞ¿Ñ€Ğ¾ÑÑ‚Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ Ğ¾ÑˆĞ¸Ğ±ĞºĞ¸ Ñ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸ĞµĞ¼ Ğ²ĞµÑĞ¾Ğ².

> ### 2. ğŸ” ĞšĞ Ğ˜ĞŸĞ¢ĞĞĞĞĞ›Ğ˜Ğ¢Ğ˜Ğ§Ğ•Ğ¡ĞšĞ˜Ğ• Ğ¤Ğ£ĞĞšĞ¦Ğ˜Ğ˜

&emsp;&emsp;ĞĞ°Ğ±Ğ¾Ñ€ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¹ Ğ´Ğ»Ñ Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸ Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ¾Ğ² ĞºÑ€Ğ¸Ğ¿Ñ‚Ğ¾Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ·Ğ°:

&emsp;&emsp;**â€¢ ĞœĞµÑ‚Ğ¾Ğ´ ĞšĞ°Ğ·Ğ¸ÑĞºĞ¸** - Ğ¿Ğ¾Ğ¸ÑĞº Ğ¿Ğ¾Ğ²Ñ‚Ğ¾Ñ€ÑÑÑ‰Ğ¸Ñ…ÑÑ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚ĞµĞ¹ Ğ´Ğ»Ñ Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ñ Ğ´Ğ»Ğ¸Ğ½Ñ‹ ĞºĞ»ÑÑ‡Ğ°;

&emsp;&emsp;**â€¢ Ğ§Ğ°ÑÑ‚Ğ¾Ñ‚Ğ½Ñ‹Ğ¹ Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ·** - ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹ Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ· Ñ€Ğ°ÑĞ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ñ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ²;

&emsp;&emsp;**â€¢ Ğ”ĞµÑˆĞ¸Ñ„Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ** - Ğ¾Ğ±Ñ€Ğ°Ñ‚Ğ½Ğ¾Ğµ Ğ¿Ñ€ĞµĞ¾Ğ±Ñ€Ğ°Ğ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ’Ğ¸Ğ¶ĞµĞ½ĞµÑ€Ğ° Ñ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ½Ñ‹Ğ¼ ĞºĞ»ÑÑ‡Ğ¾Ğ¼;

&emsp;&emsp;**â€¢ ĞĞ²Ñ‚Ğ¾Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ğµ ÑĞ·Ñ‹ĞºĞ°** - Ñ€Ğ°ÑĞ¿Ğ¾Ğ·Ğ½Ğ°Ğ²Ğ°Ğ½Ğ¸Ğµ Ñ€ÑƒÑÑĞºĞ¾Ğ³Ğ¾ Ğ¸ Ğ°Ğ½Ğ³Ğ»Ğ¸Ğ¹ÑĞºĞ¾Ğ³Ğ¾ Ñ‚ĞµĞºÑÑ‚Ğ¾Ğ².

<div align="center">

## ğŸŒ ĞŸĞĞ”Ğ”Ğ•Ğ Ğ–Ğ˜Ğ’ĞĞ•ĞœĞ«Ğ• Ğ’ĞĞ—ĞœĞĞ–ĞĞĞ¡Ğ¢Ğ˜

</div>

&emsp;&emsp;**Ğ¯Ğ·Ñ‹ĞºĞ¸:**  
&emsp;&emsp;&emsp;&emsp;â€¢ Ğ ÑƒÑÑĞºĞ¸Ğ¹ (Ñ ÑƒÑ‡ĞµÑ‚Ğ¾Ğ¼ Ğ±ÑƒĞºĞ² Ğ/Ğ• Ğ¸ Ñ€Ğ°Ğ·Ğ»Ğ¸Ñ‡Ğ½Ñ‹Ñ… Ğ¿Ğ¾Ñ€ÑĞ´ĞºĞ¾Ğ² Ğ°Ğ»Ñ„Ğ°Ğ²Ğ¸Ñ‚Ğ°);

&emsp;&emsp;&emsp;&emsp;â€¢ ĞĞ½Ğ³Ğ»Ğ¸Ğ¹ÑĞºĞ¸Ğ¹ (ÑÑ‚Ğ°Ğ½Ğ´Ğ°Ñ€Ñ‚Ğ½Ñ‹Ğ¹ Ğ»Ğ°Ñ‚Ğ¸Ğ½ÑĞºĞ¸Ğ¹ Ğ°Ğ»Ñ„Ğ°Ğ²Ğ¸Ñ‚).

&emsp;&emsp;**ĞœĞµÑ‚Ğ¾Ğ´Ñ‹ ĞºÑ€Ğ¸Ğ¿Ñ‚Ğ¾Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ·Ğ°:**  
&emsp;&emsp;&emsp;&emsp;â€¢ ĞĞ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¾Ğµ Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ğµ Ğ´Ğ»Ğ¸Ğ½Ñ‹ ĞºĞ»ÑÑ‡Ğ° (2-20 ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ²);

&emsp;&emsp;&emsp;&emsp;â€¢ Ğ§Ğ°ÑÑ‚Ğ¾Ñ‚Ğ½Ñ‹Ğ¹ Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ· Ñ ÑƒÑ‡ĞµÑ‚Ğ¾Ğ¼ ÑĞ·Ñ‹ĞºĞ¾Ğ²Ñ‹Ñ… Ğ¾ÑĞ¾Ğ±ĞµĞ½Ğ½Ğ¾ÑÑ‚ĞµĞ¹;

&emsp;&emsp;&emsp;&emsp;â€¢ Ğ˜Ğ½Ñ‚ĞµĞ»Ğ»ĞµĞºÑ‚ÑƒĞ°Ğ»ÑŒĞ½Ğ°Ñ Ğ¾Ñ†ĞµĞ½ĞºĞ° Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ğ¾Ğ² Ñ‡ĞµÑ€ĞµĞ· Ğ½ĞµĞ¹Ñ€Ğ¾ÑĞµÑ‚ÑŒ;

&emsp;&emsp;&emsp;&emsp;â€¢ Ğ Ğ°Ğ½Ğ¶Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ²Ğ°Ñ€Ğ¸Ğ°Ğ½Ñ‚Ğ¾Ğ² Ğ¿Ğ¾ Ğ²ĞµÑ€Ğ¾ÑÑ‚Ğ½Ğ¾ÑÑ‚Ğ¸ Ğ¾ÑĞ¼Ñ‹ÑĞ»ĞµĞ½Ğ½Ğ¾ÑÑ‚Ğ¸.

&emsp;&emsp;**ĞÑĞ¾Ğ±ĞµĞ½Ğ½Ğ¾ÑÑ‚Ğ¸ Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸:**  
&emsp;&emsp;&emsp;&emsp;â€¢ ĞĞ±ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ½ĞµĞ¹Ñ€Ğ¾ÑĞµÑ‚Ğ¸ Ğ½Ğ° Ñ€Ğ°Ğ·Ğ¼ĞµÑ‡ĞµĞ½Ğ½Ñ‹Ñ… Ğ´Ğ°Ñ‚Ğ°ÑĞµÑ‚Ğ°Ñ…;

&emsp;&emsp;&emsp;&emsp;â€¢ ĞŸĞ¾Ğ´Ğ´ĞµÑ€Ğ¶ĞºĞ° Ñ€Ğ°Ğ·Ğ»Ğ¸Ñ‡Ğ½Ñ‹Ñ… Ğ°Ğ»Ñ„Ğ°Ğ²Ğ¸Ñ‚Ğ½Ñ‹Ñ… Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚ĞµĞ¹;

&emsp;&emsp;&emsp;&emsp;â€¢ Ğ’Ğ¸Ğ·ÑƒĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ¿Ñ€Ğ¾Ñ†ĞµÑÑĞ° Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ·Ğ° Ğ² Ñ€ĞµĞ°Ğ»ÑŒĞ½Ğ¾Ğ¼ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ¸;

&emsp;&emsp;&emsp;&emsp;â€¢ Ğ˜Ğ½Ñ‚ĞµÑ€Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğ¹ Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ Ğ´Ğ»Ñ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹ Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¼.

<div align="center">

## ğŸ”„ ĞŸĞ ĞĞ¦Ğ•Ğ¡Ğ¡ Ğ ĞĞ‘ĞĞ¢Ğ«

</div>

**1. Ğ˜Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ** - Ğ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ° Ğ¸ Ğ¾Ğ±ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ½ĞµĞ¹Ñ€Ğ¾ÑĞµÑ‚Ğ¸ Ğ½Ğ° Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€Ğ°Ñ… Ñ‚ĞµĞºÑÑ‚Ğ¾Ğ²;

**2. Ğ’Ğ²Ğ¾Ğ´ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…** - Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ·Ğ°ÑˆĞ¸Ñ„Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ¾Ğ³Ğ¾ Ñ‚ĞµĞºÑÑ‚Ğ° Ğ¾Ñ‚ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ;

**3. ĞĞ½Ğ°Ğ»Ğ¸Ğ·** - Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ¾Ğµ Ğ¿Ñ€Ğ¸Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğµ Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ¾Ğ² ĞšĞ°Ğ·Ğ¸ÑĞºĞ¸ Ğ¸ Ñ‡Ğ°ÑÑ‚Ğ¾Ñ‚Ğ½Ğ¾Ğ³Ğ¾ Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ·Ğ°;

**4. ĞÑ†ĞµĞ½ĞºĞ°** - ĞºĞ»Ğ°ÑÑĞ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ñ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ğ¾Ğ² Ñ Ğ¿Ğ¾Ğ¼Ğ¾Ñ‰ÑŒÑ Ğ½ĞµĞ¹Ñ€Ğ¾ÑĞµÑ‚Ğ¸;

**5. Ğ’Ñ‹Ğ²Ğ¾Ğ´** - Ğ¿Ñ€ĞµĞ´ÑÑ‚Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ»ÑƒÑ‡ÑˆĞ¸Ñ… Ğ²Ğ°Ñ€Ğ¸Ğ°Ğ½Ñ‚Ğ¾Ğ² Ñ€Ğ°ÑÑˆĞ¸Ñ„Ñ€Ğ¾Ğ²ĞºĞ¸ Ñ Ñ€Ğ°Ğ½Ğ¶Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸ĞµĞ¼.

<div align="center">

âœ¨âœ¨â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”âœ¨âœ¨

<a href="https://git.io/typing-svg"><img src="https://readme-typing-svg.demolab.com?font=Momo+Trust+Display&size=60&duration=6000&pause=1000&color=3B9600&center=true&vCenter=true&width=1000&height=110&lines=%F0%9F%94%8D+%D0%9F%D0%A0%D0%98%D0%9D%D0%A6%D0%98%D0%9F+%D0%A0%D0%90%D0%91%D0%9E%D0%A2%D0%AB+%D0%92%D0%97%D0%9B%D0%9E%D0%9C%D0%90+%F0%9F%94%8D" alt="Typing SVG" /></a>

## ğŸ› ï¸ Ğ¡Ñ…ĞµĞ¼Ğ° Ğ²Ğ·Ğ»Ğ¾Ğ¼Ğ° ÑˆĞ¸Ñ„Ñ€Ğ° Ğ’Ğ¸Ğ¶ĞµĞ½ĞµÑ€Ğ° ğŸ› ï¸

</div>

| Ğ­Ñ‚Ğ°Ğ¿ | Ğ‘Ğ»Ğ¾Ğº | ĞœĞµÑ‚Ğ¾Ğ´ | ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ | Ğ ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚ |
|------|------|-------|----------|-----------|
| **1** | **ĞĞ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ğµ Ğ´Ğ»Ğ¸Ğ½Ñ‹ ĞºĞ»ÑÑ‡Ğ°** | ĞœĞµÑ‚Ğ¾Ğ´ ĞšĞ°Ğ·Ğ¸ÑĞºĞ¸ | ĞŸĞ¾Ğ¸ÑĞº Ğ¿Ğ¾Ğ²Ñ‚Ğ¾Ñ€ÑÑÑ‰Ğ¸Ñ…ÑÑ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚ĞµĞ¹ (3-5 ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ²) Ğ¸ Ğ²Ñ‹Ñ‡Ğ¸ÑĞ»ĞµĞ½Ğ¸Ğµ ĞĞĞ” Ñ€Ğ°ÑÑÑ‚Ğ¾ÑĞ½Ğ¸Ğ¹ Ğ¼ĞµĞ¶Ğ´Ñƒ Ğ½Ğ¸Ğ¼Ğ¸ | Ğ”Ğ»Ğ¸Ğ½Ğ° ĞºĞ»ÑÑ‡Ğ° |
| **2** | **Ğ Ğ°Ğ·Ğ´ĞµĞ»ĞµĞ½Ğ¸Ğµ Ğ½Ğ° Ğ³Ñ€ÑƒĞ¿Ğ¿Ñ‹** | Ğ Ğ°ÑĞ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ğµ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ² | Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ N Ğ³Ñ€ÑƒĞ¿Ğ¿ (Ğ³Ğ´Ğµ N - Ğ´Ğ»Ğ¸Ğ½Ğ° ĞºĞ»ÑÑ‡Ğ°) Ğ¸ Ñ€Ğ°ÑĞ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ğµ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ²: i-Ğ¹ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ» â†’ Ğ³Ñ€ÑƒĞ¿Ğ¿Ğ°[i % N] | Ğ“Ñ€ÑƒĞ¿Ğ¿Ñ‹ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ² |
| **3** | **Ğ§Ğ°ÑÑ‚Ğ¾Ñ‚Ğ½Ñ‹Ğ¹ Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ·** | Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹ Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ· | Ğ”Ğ»Ñ ĞºĞ°Ğ¶Ğ´Ğ¾Ğ¹ Ğ³Ñ€ÑƒĞ¿Ğ¿Ñ‹: Ğ¿Ğ¾Ğ´ÑÑ‡ĞµÑ‚ Ñ‡Ğ°ÑÑ‚Ğ¾Ñ‚, Ğ½Ğ°Ñ…Ğ¾Ğ¶Ğ´ĞµĞ½Ğ¸Ğµ ÑĞ°Ğ¼Ğ¾Ğ³Ğ¾ Ñ‡Ğ°ÑÑ‚Ğ¾Ğ³Ğ¾ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ°, ÑÑ€Ğ°Ğ²Ğ½ĞµĞ½Ğ¸Ğµ Ñ 'E'/'Ğ' Ğ´Ğ»Ñ Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ñ ÑĞ´Ğ²Ğ¸Ğ³Ğ° | Ğ‘ÑƒĞºĞ²Ñ‹ ĞºĞ»ÑÑ‡Ğ° |
| **4** | **Ğ’Ğ¾ÑÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ ĞºĞ»ÑÑ‡Ğ°** | ĞĞ±ÑŠĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğµ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ğ¾Ğ² | ĞšĞ¾Ğ¼Ğ±Ğ¸Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ½Ñ‹Ñ… Ğ±ÑƒĞºĞ² Ğ¸Ğ· Ğ²ÑĞµÑ… Ğ³Ñ€ÑƒĞ¿Ğ¿ Ğ² Ğ¿Ğ¾Ğ»Ğ½Ñ‹Ğ¹ ĞºĞ»ÑÑ‡ | ĞšĞ»ÑÑ‡ ÑˆĞ¸Ñ„Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ |
| **5** | **Ğ”ĞµÑˆĞ¸Ñ„Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ** | ĞĞ±Ñ€Ğ°Ñ‚Ğ½Ğ¾Ğµ Ğ¿Ñ€ĞµĞ¾Ğ±Ñ€Ğ°Ğ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ | ĞŸÑ€Ğ¸Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğµ Ğ¾Ğ±Ñ€Ğ°Ñ‚Ğ½Ğ¾Ğ³Ğ¾ ÑˆĞ¸Ñ„Ñ€Ğ° Ğ’Ğ¸Ğ¶ĞµĞ½ĞµÑ€Ğ° Ñ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ½Ñ‹Ğ¼ ĞºĞ»ÑÑ‡Ğ¾Ğ¼ | Ğ Ğ°ÑÑˆĞ¸Ñ„Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¹ Ñ‚ĞµĞºÑÑ‚ |
| **6** | **ğŸ§  ĞÑ†ĞµĞ½ĞºĞ° Ğ½ĞµĞ¹Ñ€Ğ¾ÑĞµÑ‚ÑŒÑ** | **ĞĞµĞ¹Ñ€Ğ¾Ğ½Ğ½Ğ°Ñ ÑĞµÑ‚ÑŒ** | **ĞĞ½Ğ°Ğ»Ğ¸Ğ· Ğ¾ÑĞ¼Ñ‹ÑĞ»ĞµĞ½Ğ½Ğ¾ÑÑ‚Ğ¸ Ñ‚ĞµĞºÑÑ‚Ğ° Ñ‡ĞµÑ€ĞµĞ· Ğ¿ĞµÑ€Ñ†ĞµĞ¿Ñ‚Ñ€Ğ¾Ğ½, Ğ¾Ğ±ÑƒÑ‡ĞµĞ½Ğ½Ñ‹Ğ¹ Ğ½Ğ° Ñ‚Ñ€Ğ¸Ğ³Ñ€Ğ°Ğ¼Ğ¼Ğ°Ñ… Ğ¸ Ñ‡Ğ°ÑÑ‚Ğ¾Ñ‚Ğ½Ğ¾ÑÑ‚Ğ¸ Ğ±ÑƒĞºĞ²** | **Ğ’ĞµÑ€Ğ¾ÑÑ‚Ğ½Ğ¾ÑÑ‚ÑŒ Ğ¾ÑĞ¼Ñ‹ÑĞ»ĞµĞ½Ğ½Ğ¾ÑÑ‚Ğ¸** |

<div align="center">

âœ¨âœ¨â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”âœ¨âœ¨

<a href="https://git.io/typing-svg"><img src="https://readme-typing-svg.demolab.com?font=Momo+Trust+Display&size=45&duration=6000&pause=1000&color=3B9600&center=true&vCenter=true&width=1000&height=80&lines=%F0%9F%A7%A0+%D0%9D%D0%95%D0%99%D0%A0%D0%9E%D0%A1%D0%95%D0%A2%D0%AC+%D0%92+%D0%9A%D0%A0%D0%98%D0%9F%D0%A2%D0%9E%D0%90%D0%9D%D0%90%D0%9B%D0%98%D0%97%D0%95+%F0%9F%A7%A0" alt="Typing SVG" /></a>

## ğŸ§  Ğ˜Ğ½Ğ½Ğ¾Ğ²Ğ°Ñ†Ğ¸Ğ¾Ğ½Ğ½Ñ‹Ğ¹ Ğ¿Ğ¾Ğ´Ñ…Ğ¾Ğ´: Ğ¸Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ñ Ğ½ĞµĞ¹Ñ€Ğ¾ÑĞµÑ‚Ğ¸

</div>

### ğŸ¤” **ĞŸÑ€Ğ¾Ğ±Ğ»ĞµĞ¼Ğ° Ñ‚Ñ€Ğ°Ğ´Ğ¸Ñ†Ğ¸Ğ¾Ğ½Ğ½Ñ‹Ñ… Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ¾Ğ²**
&emsp;&emsp;&emsp;&emsp;ĞšĞ»Ğ°ÑÑĞ¸Ñ‡ĞµÑĞºĞ¸Ğ¹ Ğ²Ğ·Ğ»Ğ¾Ğ¼ ÑˆĞ¸Ñ„Ñ€Ğ° Ğ’Ğ¸Ğ¶ĞµĞ½ĞµÑ€Ğ° Ñ‡Ğ°ÑÑ‚Ğ¾ Ğ´Ğ°ĞµÑ‚ **Ğ½ĞµÑĞºĞ¾Ğ»ÑŒĞºĞ¾ Ğ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ñ‹Ñ… Ğ²Ğ°Ñ€Ğ¸Ğ°Ğ½Ñ‚Ğ¾Ğ²** Ñ€Ğ°ÑÑˆĞ¸Ñ„Ñ€Ğ¾Ğ²ĞºĞ¸. Ğ‘ĞµĞ· Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¾Ğ¹ Ğ¾Ñ†ĞµĞ½ĞºĞ¸ ĞºĞ°Ñ‡ĞµÑÑ‚Ğ²Ğ° Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ğ¾Ğ² Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ¿Ñ€Ğ¸Ñ…Ğ¾Ğ´Ğ¸Ñ‚ÑÑ **Ğ²Ñ€ÑƒÑ‡Ğ½ÑƒÑ Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ** ĞºĞ°Ğ¶Ğ´Ñ‹Ğ¹ Ğ²Ğ°Ñ€Ğ¸Ğ°Ğ½Ñ‚ Ğ½Ğ° Ğ¾ÑĞ¼Ñ‹ÑĞ»ĞµĞ½Ğ½Ğ¾ÑÑ‚ÑŒ.

### ğŸ’¡ **Ğ ĞµÑˆĞµĞ½Ğ¸Ğµ: Ğ½ĞµĞ¹Ñ€Ğ¾ÑĞµÑ‚ÑŒ-ĞºĞ»Ğ°ÑÑĞ¸Ñ„Ğ¸ĞºĞ°Ñ‚Ğ¾Ñ€**
&emsp;&emsp;&emsp;&emsp;Ğ‘Ñ‹Ğ»Ğ¾ Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ¾Ğ²Ğ°Ğ½Ğ¾ **Ğ¸Ğ½Ñ‚ĞµĞ»Ğ»ĞµĞºÑ‚ÑƒĞ°Ğ»ÑŒĞ½Ğ¾Ğµ Ñ€ĞµÑˆĞµĞ½Ğ¸Ğµ** - Ğ¼Ğ½Ğ¾Ğ³Ğ¾ÑĞ»Ğ¾Ğ¹Ğ½Ñ‹Ğ¹ Ğ¿ĞµÑ€Ñ†ĞµĞ¿Ñ‚Ñ€Ğ¾Ğ½, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğ¹ Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ·Ğ¸Ñ€ÑƒĞµÑ‚ Ñ€Ğ°ÑÑˆĞ¸Ñ„Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğµ Ñ‚ĞµĞºÑÑ‚Ñ‹ Ğ¸ Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ÑĞµÑ‚ Ğ¸Ñ… Ğ¾ÑĞ¼Ñ‹ÑĞ»ĞµĞ½Ğ½Ğ¾ÑÑ‚ÑŒ:

```cpp
class TextTypePerceptron {
    // ĞĞ½Ğ°Ğ»Ğ¸Ğ· Ğ»Ğ¸Ğ½Ğ³Ğ²Ğ¸ÑÑ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ñ… Ğ¾ÑĞ¾Ğ±ĞµĞ½Ğ½Ğ¾ÑÑ‚ĞµĞ¹:
    // â€¢ Ğ§Ğ°ÑÑ‚Ğ¾Ñ‚Ğ½Ğ¾ÑÑ‚ÑŒ Ñ‚Ñ€Ğ¸Ğ³Ñ€Ğ°Ğ¼Ğ¼ ("Ğ¡Ğ¢Ğ", "Ğ•ĞĞ˜", "THE", "AND")
    // â€¢ Ğ Ğ°ÑĞ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ğµ Ğ±ÑƒĞºĞ² ('Ğ', 'Ğ•', 'Ğ', 'E', 'T', 'A')  
    // â€¢ Ğ¡Ğ¾Ğ¾Ñ‚Ğ½Ğ¾ÑˆĞµĞ½Ğ¸Ğµ Ğ³Ğ»Ğ°ÑĞ½Ñ‹Ñ…/ÑĞ¾Ğ³Ğ»Ğ°ÑĞ½Ñ‹Ñ…
    // â€¢ Ğ ĞµĞ´ĞºĞ¸Ğµ Ğ±ÑƒĞºĞ²Ñ‹ ('Ğ¤', 'Ğ©', 'Z', 'Q')
};
```

> P.s. ĞĞ° ÑÑ‚Ğ¾Ğ¼ Ğ²ÑĞµ!!! ĞÑÑ‚Ğ°Ğ»ÑŒĞ½Ğ¾Ğµ Ğ¼Ğ½Ğµ Ğ»ĞµĞ½ÑŒ Ñ€Ğ°ÑÑĞ¿Ğ¸ÑÑ‹Ğ²Ğ°Ñ‚ÑŒ. Ğ”Ğ°Ğ»ÑŒÑˆĞµ ÑĞ°Ğ¼Ğ¸...

<div align="center">

![](https://media1.tenor.com/m/ThULTnx4eUgAAAAd/squirrel-spinning-around.gif)

âœ¨âœ¨â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”âœ¨âœ¨

<a href="https://git.io/typing-svg"><img src="https://readme-typing-svg.demolab.com?font=EB+Garamond&size=90&duration=6000&pause=1000&color=3B9600&center=true&vCenter=true&width=1000&height=110&lines=-+%D0%90%D0%92%D0%A2%D0%9E%D0%A0+-+" alt="Typing SVG" /></a>

<a href="https://git.io/typing-svg"><img src="https://readme-typing-svg.demolab.com?font=Sixtyfour&size=70&duration=6000&pause=1000&color=000000&background=07BD1B&center=true&vCenter=true&repeat=false&width=1000&height=110&lines=%E2%94%81%E2%94%81%E2%94%81%E2%94%81%E2%9C%A6+C.C.+%E2%9C%A6%E2%94%81%E2%94%81%E2%94%81%E2%94%81;%E2%95%90%E2%95%90%E2%95%90%E2%95%90%E2%99%A6+C.C.+%E2%99%A6%E2%95%90%E2%95%90%E2%95%90%E2%95%90;%E2%94%85%E2%94%85%E2%94%85%E2%9C%A7+C.C.+%E2%9C%A7%E2%94%85%E2%94%85%E2%94%85;%E2%95%8D%E2%95%8D%E2%95%8D%E2%99%A0+C.C.+%E2%99%A0%E2%95%8D%E2%95%8D%E2%95%8D;%E3%80%9C%E3%80%9C%E3%80%9C%E2%8C%AC+C.C.+%E2%8C%AC%E3%80%9C%E3%80%9C%E3%80%9C;%E2%9C%A6%E2%9C%A6+C.C.+%E2%9C%A6%E2%9C%A6;%E2%9A%A1%E2%9A%A1+C.C.+%E2%9A%A1%E2%9A%A1;%F0%9F%8E%AE%F0%9F%8E%AE+C.C.+%F0%9F%8E%AE%F0%9F%8E%AE" alt="Typing SVG" /></a>

[![C.C.](https://img.shields.io/badge/-C.C.-3B9600?style=for-the-badge&logo=star&logoColor=white&labelColor=0d1117)](https://github.com/C-C-C0de)

âœ¨âœ¨â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”âœ¨âœ¨

<a href="https://git.io/typing-svg"><img src="https://readme-typing-svg.demolab.com?font=EB+Garamond&size=90&duration=6000&pause=1000&color=3B9600&center=true&vCenter=true&width=1000&height=110&lines=%D0%9A%D0%9E%D0%94+%D0%A1%2B%2B" alt="Typing SVG" /></a>

![Views](https://visitor-badge.laobi.icu/badge?page_id=C-C-C0de.Vigener-encryption)

</div>

```Cpp
#include <iostream>
#include <string>
#include <map>
#include <windows.h>
#include <algorithm>
#include <cmath>

using namespace std;

class TextTypePerceptron {
private:
    double weights[10];
    double bias;
    double learning_rate;

public:
    TextTypePerceptron() {
        learning_rate = 0.1;
        bias = 0.0;
        for (int i = 0; i < 10; i++) {
            weights[i] = 0.5;
        }
    }

    double sigmoid(double x) {
        return 1.0 / (1.0 + exp(-x));
    }

    double sigmoid_derivative(double x) {
        return x * (1 - x);
    }

    double letterFrequency(const string& text, char letter) {
        int count = 0;
        for (int i = 0; i < text.length(); i++) {
            if (toupper(text[i]) == toupper(letter)) count++;
        }
        return text.length() > 0 ? (double)count / text.length() : 0;
    }

    double trigramFrequency(const string& text, const string& trigram) {
        int count = 0;
        for (int i = 0; i < (int)text.length() - 2; i++) {
            if (toupper(text[i]) == toupper(trigram[0]) &&
                toupper(text[i + 1]) == toupper(trigram[1]) &&
                toupper(text[i + 2]) == toupper(trigram[2])) {
                count++;
            }
        }
        return text.length() > 2 ? (double)count / (text.length() - 2) : 0;
    }

    double vowelRatio(const string& text, const string& language) {
        int vowels = 0;
        string vowelLetters;

        if (language == "russian") {
            vowelLetters = "ĞĞ•ĞĞ˜ĞĞ£Ğ«Ğ­Ğ®Ğ¯Ğ°ĞµÑ‘Ğ¸Ğ¾ÑƒÑ‹ÑÑÑ";
        }
        else {
            vowelLetters = "AEIOUaeiou";
        }

        for (int i = 0; i < text.length(); i++) {
            if (vowelLetters.find(text[i]) != string::npos) vowels++;
        }
        return text.length() > 0 ? (double)vowels / text.length() : 0;
    }

    void extractFeatures(const string& text, double features[10], const string& language) {
        if (language == "russian") {
            features[0] = trigramFrequency(text, "Ğ¡Ğ¢Ğ");
            features[1] = trigramFrequency(text, "Ğ•ĞĞ˜");
            features[2] = trigramFrequency(text, "ĞĞ’Ğ");

            features[3] = letterFrequency(text, 'Ğ');
            features[4] = letterFrequency(text, 'Ğ•');
            features[5] = letterFrequency(text, 'Ğ');

            features[6] = vowelRatio(text, "russian");

            features[7] = letterFrequency(text, 'Ğ¤');
            features[8] = letterFrequency(text, 'Ğ©');
            features[9] = letterFrequency(text, 'Ğ­');
        }
        else {
            features[0] = trigramFrequency(text, "THE");
            features[1] = trigramFrequency(text, "AND");
            features[2] = trigramFrequency(text, "ING");

            features[3] = letterFrequency(text, 'E');
            features[4] = letterFrequency(text, 'T');
            features[5] = letterFrequency(text, 'A');

            features[6] = vowelRatio(text, "english");

            features[7] = letterFrequency(text, 'Z');
            features[8] = letterFrequency(text, 'Q');
            features[9] = letterFrequency(text, 'X');
        }
    }

    double predict(const string& text, const string& language) {
        double features[10];
        extractFeatures(text, features, language);

        double sum = bias;
        for (int i = 0; i < 10; i++) {
            sum += weights[i] * features[i];
        }

        return sigmoid(sum);
    }

    void trainExample(const string& text, double target, const string& language) {
        double features[10];
        extractFeatures(text, features, language);

        double prediction = predict(text, language);
        double error = target - prediction;
        double delta = error * sigmoid_derivative(prediction);

        for (int i = 0; i < 10; i++) {
            weights[i] += learning_rate * delta * features[i];
        }
        bias += learning_rate * delta;
    }

    void train(const string training_texts[10], double targets[10], int epochs, const string& language) {
        cout << "ĞĞ°Ñ‡Ğ¸Ğ½Ğ°ĞµĞ¼ Ğ¾Ğ±ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ´Ğ»Ñ " << (language == "russian" ? "Ñ€ÑƒÑÑĞºĞ¾Ğ³Ğ¾" : "Ğ°Ğ½Ğ³Ğ»Ğ¸Ğ¹ÑĞºĞ¾Ğ³Ğ¾") << " ÑĞ·Ñ‹ĞºĞ°..." << endl;

        for (int epoch = 0; epoch < epochs; epoch++) {
            double total_error = 0;

            for (int i = 0; i < 10; i++) {
                double prediction = predict(training_texts[i], language);
                double error = targets[i] - prediction;
                total_error += error * error;
                trainExample(training_texts[i], targets[i], language);
            }

            if (epoch % 1000 == 0) {
                cout << "Ğ­Ğ¿Ğ¾Ñ…Ğ° " << epoch << ", ĞÑˆĞ¸Ğ±ĞºĞ°: " << total_error << endl;
            }
        }
        cout << "ĞĞ±ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¾!" << endl;
    }

    string getTextType(double probability) {
        if (probability > 0.7) return "ĞĞ¡ĞœĞ«Ğ¡Ğ›Ğ•ĞĞĞ«Ğ™ Ğ¢Ğ•ĞšĞ¡Ğ¢";
        else if (probability > 0.4) return "Ğ§ĞĞ¡Ğ¢Ğ˜Ğ§ĞĞ ĞĞ¡ĞœĞ«Ğ¡Ğ›Ğ•ĞĞĞ«Ğ™ Ğ¢Ğ•ĞšĞ¡Ğ¢";
        else return "Ğ¡Ğ›Ğ£Ğ§ĞĞ™ĞĞ«Ğ™ Ğ¢Ğ•ĞšĞ¡Ğ¢ Ğ˜Ğ›Ğ˜ Ğ¨Ğ£Ğœ";
    }
};

int gcd(int a, int b) {
    while (b != 0) {
        int temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}

int findGCD(int distances[], int count) {
    if (count == 0) return 0;
    int result = distances[0];
    for (int i = 1; i < count; i++) {
        result = gcd(result, distances[i]);
        if (result == 1) break;
    }
    return result;
}

bool isRussianLetter(char c) {
    return (c >= 'Ğ' && c <= 'Ğ¯') || (c >= 'Ğ°' && c <= 'Ñ') || c == 'Ğ' || c == 'Ñ‘';
}

bool isEnglishLetter(char c) {
    return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');
}

char toUpperRussian(char c) {
    if (c >= 'Ğ°' && c <= 'Ñ') return c - 32;
    if (c == 'Ñ‘') return 'Ğ';
    return c;
}

char toUpperEnglish(char c) {
    if (c >= 'a' && c <= 'z') return c - 32;
    return c;
}

string detectLanguage(const string& text) {
    int russianCount = 0;
    int englishCount = 0;

    for (char c : text) {
        if (isRussianLetter(c)) russianCount++;
        else if (isEnglishLetter(c)) englishCount++;
    }

    if (russianCount > englishCount) return "russian";
    if (englishCount > russianCount) return "english";
    return "unknown";
}

string prepareText(const string& text, const string& language) {
    string result;
    for (int i = 0; i < text.length(); i++) {
        char c = text[i];
        if (language == "russian" && isRussianLetter(c)) {
            result += toUpperRussian(c);
        }
        else if (language == "english" && isEnglishLetter(c)) {
            result += toUpperEnglish(c);
        }
    }
    return result;
}

void getPossibleAlphabets(const string& language, string alphabets[4], int& alphabetCount) {
    alphabetCount = 0;

    if (language == "russian") {
        alphabets[alphabetCount++] = "ĞĞ‘Ğ’Ğ“Ğ”Ğ•ĞĞ–Ğ—Ğ˜Ğ™ĞšĞ›ĞœĞĞĞŸĞ Ğ¡Ğ¢Ğ£Ğ¤Ğ¥Ğ¦Ğ§Ğ¨Ğ©ĞªĞ«Ğ¬Ğ­Ğ®Ğ¯";
        alphabets[alphabetCount++] = "ĞĞ‘Ğ’Ğ“Ğ”Ğ•Ğ–Ğ—Ğ˜Ğ™ĞšĞ›ĞœĞĞĞŸĞ Ğ¡Ğ¢Ğ£Ğ¤Ğ¥Ğ¦Ğ§Ğ¨Ğ©ĞªĞ«Ğ¬Ğ­Ğ®Ğ¯";
        alphabets[alphabetCount++] = "ĞĞ‘Ğ’Ğ“Ğ”Ğ•ĞĞ–Ğ—Ğ˜Ğ™ĞšĞ›ĞœĞĞĞŸĞ Ğ¡Ğ¢Ğ£Ğ¤Ğ¥Ğ¦Ğ§Ğ¨Ğ©Ğ¬Ğ«ĞªĞ­Ğ®Ğ¯";
        alphabets[alphabetCount++] = "ĞĞ‘Ğ’Ğ“Ğ”Ğ•Ğ–Ğ—Ğ˜Ğ™ĞšĞ›ĞœĞĞĞŸĞ Ğ¡Ğ¢Ğ£Ğ¤Ğ¥Ğ¦Ğ§Ğ¨Ğ©Ğ¬Ğ«ĞªĞ­Ğ®Ğ¯";
    }
    else {
        alphabets[alphabetCount++] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        alphabetCount = 1;
    }
}

void findDivisors(int n, int divisors[], int& divisorCount) {
    divisorCount = 0;
    for (int i = 1; i <= n && i <= 20; i++) {
        if (n % i == 0) {
            divisors[divisorCount++] = i;
        }
    }
}

char frequencyAnalysisWithAlphabet(const string& group, const string& alphabet, const string& language) {
    int n = alphabet.length();
    int freq[50] = { 0 };
    for (char c : group) {
        size_t pos = alphabet.find(c);
        if (pos != string::npos && pos < 50) {
            freq[pos]++;
        }
    }
    int maxFreq = 0;
    int mostFrequentIndex = 0;

    for (int i = 0; i < n && i < 50; i++) {
        if (freq[i] > maxFreq) {
            maxFreq = freq[i];
            mostFrequentIndex = i;
        }
    }

    char referenceChar;
    if (language == "russian") {
        referenceChar = 'Ğ';
    }
    else {
        string commonLetters = "ETAOINSHRDLCUMWFGYPBVKJXQZ";
        int bestScore = -1;
        char bestChar = 'E';

        for (char commonChar : commonLetters) {
            int commonIndex = alphabet.find(commonChar);
            if (commonIndex == string::npos) continue;

            int shift = (mostFrequentIndex - commonIndex + n) % n;

            int score = 0;
            for (int i = 0; i < n && i < 50; i++) {
                if (freq[i] > 0) {
                    char decryptedChar = alphabet[(i - shift + n) % n];
                    if (decryptedChar == 'E' || decryptedChar == 'T' || decryptedChar == 'A' ||
                        decryptedChar == 'O' || decryptedChar == 'I' || decryptedChar == 'N') {
                        score += freq[i] * 3;
                    }
                    else if (decryptedChar >= 'A' && decryptedChar <= 'Z') {
                        score += freq[i];
                    }
                }
            }

            if (score > bestScore) {
                bestScore = score;
                bestChar = commonChar;
            }
        }
        referenceChar = bestChar;
    }

    int referenceIndex = alphabet.find(referenceChar);
    if (referenceIndex == string::npos) {
        referenceIndex = 0;
    }

    int shift = (mostFrequentIndex - referenceIndex + n) % n;
    return alphabet[shift];
}

string decryptVigenereWithAlphabet(const string& ciphertext, const string& key, const string& alphabet) {
    string plaintext;
    int keyLength = key.length();
    int n = alphabet.length();

    for (int i = 0; i < ciphertext.length(); i++) {
        char c = ciphertext[i];
        char k = key[i % keyLength];

        int cipherIndex = alphabet.find(c);
        int keyIndex = alphabet.find(k);

        if (cipherIndex != string::npos && keyIndex != string::npos) {
            int plainIndex = (cipherIndex - keyIndex + n) % n;
            plaintext += alphabet[plainIndex];
        }
        else {
            plaintext += '?';
        }
    }

    return plaintext;
}

struct DecryptionResult {
    string plaintext;
    string key;
    string alphabet;
    int keyLength;
    double probability;
};

bool compareByProbability(const DecryptionResult& a, const DecryptionResult& b) {
    return a.probability > b.probability;
}

void sortResultsByProbability(DecryptionResult results[], int count) {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - i - 1; j++) {
            if (results[j].probability < results[j + 1].probability) {
                DecryptionResult temp = results[j];
                results[j] = results[j + 1];
                results[j + 1] = temp;
            }
        }
    }
}

void kasiskiAttackWithNeuralNetwork(const string& ciphertext, const string& language, TextTypePerceptron& perceptron) {
    cout << "=== ĞĞ¢ĞĞšĞ ĞšĞĞ—Ğ˜Ğ¡ĞšĞ˜ (" << (language == "russian" ? "Ñ€ÑƒÑÑĞºĞ¸Ğ¹" : "Ğ°Ğ½Ğ³Ğ»Ğ¸Ğ¹ÑĞºĞ¸Ğ¹") << ") ===" << endl;
    cout << "Ğ—Ğ°ÑˆĞ¸Ñ„Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¹ Ñ‚ĞµĞºÑÑ‚: " << ciphertext << endl;
    cout << "Ğ”Ğ»Ğ¸Ğ½Ğ° Ñ‚ĞµĞºÑÑ‚Ğ°: " << ciphertext.length() << " ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ²" << endl << endl;

    const int MAX_DISTANCES = 100;
    const int MAX_DIVISORS = 50;
    const int MAX_RESULTS = 100;

    int distances[MAX_DISTANCES];
    int distanceCount = 0;
    int divisorFreq[21] = { 0 };

    cout << "ĞŸĞ¾Ğ¸ÑĞº Ğ¿Ğ¾Ğ²Ñ‚Ğ¾Ñ€ÑÑÑ‰Ğ¸Ñ…ÑÑ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚ĞµĞ¹..." << endl;
    cout << "=========================================" << endl;

    bool foundSequences = false;

    auto isValidChar = [&](char c) {
        if (language == "russian") return isRussianLetter(c);
        else return isEnglishLetter(c);
        };

    for (int len = 3; len <= 5; len++) {
        for (int i = 0; i <= ciphertext.length() - len; i++) {
            string sequence = ciphertext.substr(i, len);

            bool valid = true;
            for (int j = 0; j < len; j++) {
                if (!isValidChar(sequence[j])) {
                    valid = false;
                    break;
                }
            }
            if (!valid) continue;

            for (int j = i + len; j <= ciphertext.length() - len; j++) {
                string candidate = ciphertext.substr(j, len);
                if (sequence == candidate) {
                    if (!foundSequences) {
                        cout << "ĞĞ°Ğ¹Ğ´ĞµĞ½Ñ‹ Ğ¿Ğ¾Ğ²Ñ‚Ğ¾Ñ€ÑÑÑ‰Ğ¸ĞµÑÑ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚Ğ¸:" << endl;
                        foundSequences = true;
                    }
                    int distance = j - i;

                    if (distanceCount < MAX_DISTANCES) {
                        distances[distanceCount++] = distance;
                    }
                    break;
                }
            }
        }
    }

    int possibleLengths[20];
    int possibleLengthsCount = 0;

    if (foundSequences) {
        cout << "ĞĞĞĞ›Ğ˜Ğ— Ğ ĞĞ¡Ğ¡Ğ¢ĞĞ¯ĞĞ˜Ğ™:" << endl;
        cout << "=================" << endl;

        cout << "Ğ’ÑĞµ Ñ€Ğ°ÑÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ: ";
        for (int i = 0; i < distanceCount; i++) {
            cout << distances[i] << " ";
        }
        cout << endl;

        int overallGCD = findGCD(distances, distanceCount);
        cout << "ĞĞĞ” Ğ²ÑĞµÑ… Ñ€Ğ°ÑÑÑ‚Ğ¾ÑĞ½Ğ¸Ğ¹: " << overallGCD << endl;

        for (int i = 0; i < distanceCount; i++) {
            int divisors[MAX_DIVISORS];
            int divisorCount = 0;
            findDivisors(distances[i], divisors, divisorCount);

            for (int j = 0; j < divisorCount; j++) {
                if (divisors[j] > 1 && divisors[j] <= 20) {
                    divisorFreq[divisors[j]]++;
                }
            }
        }

        cout << "\nĞ¡Ğ¢ĞĞ¢Ğ˜Ğ¡Ğ¢Ğ˜ĞšĞ Ğ”Ğ•Ğ›Ğ˜Ğ¢Ğ•Ğ›Ğ•Ğ™:" << endl;
        cout << "====================" << endl;

        int maxFreq = 0;
        for (int i = 2; i <= 20; i++) {
            if (divisorFreq[i] > 0) {
                cout << "Ğ”Ğ»Ğ¸Ğ½Ğ° " << i << ": " << divisorFreq[i] << " ÑƒĞ¿Ğ¾Ğ¼Ğ¸Ğ½Ğ°Ğ½Ğ¸Ğ¹" << endl;
                if (divisorFreq[i] > maxFreq) {
                    maxFreq = divisorFreq[i];
                }
            }
        }

        cout << "\nĞ’Ğ•Ğ ĞĞ¯Ğ¢ĞĞ«Ğ• Ğ”Ğ›Ğ˜ĞĞ« ĞšĞ›Ğ®Ğ§Ğ:" << endl;
        cout << "======================" << endl;

        for (int i = 2; i <= 20; i++) {
            if (divisorFreq[i] >= maxFreq / 2 && divisorFreq[i] > 0) {
                cout << ">>> " << i << " ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ² (ÑƒĞ¿Ğ¾Ğ¼Ğ¸Ğ½Ğ°ĞµÑ‚ÑÑ " << divisorFreq[i] << " Ñ€Ğ°Ğ·)" << endl;
                if (possibleLengthsCount < 20) {
                    possibleLengths[possibleLengthsCount++] = i;
                }
            }
        }

        if (overallGCD > 1 && overallGCD <= 20) {
            bool found = false;
            for (int i = 0; i < possibleLengthsCount; i++) {
                if (possibleLengths[i] == overallGCD) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                cout << ">>> " << overallGCD << " ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ² (Ğ¾ÑĞ½Ğ¾Ğ²Ğ°Ğ½Ğ¾ Ğ½Ğ° ĞĞĞ”)" << endl;
                if (possibleLengthsCount < 20) {
                    possibleLengths[possibleLengthsCount++] = overallGCD;
                }
            }
        }
    }
    else {
        cout << "ĞĞµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾ Ğ¿Ğ¾Ğ²Ñ‚Ğ¾Ñ€ÑÑÑ‰Ğ¸Ñ…ÑÑ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚ĞµĞ¹." << endl;
        cout << "Ğ‘ÑƒĞ´ĞµĞ¼ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ ÑÑ‚Ğ°Ğ½Ğ´Ğ°Ñ€Ñ‚Ğ½Ñ‹Ğµ Ğ´Ğ»Ğ¸Ğ½Ñ‹ ĞºĞ»ÑÑ‡Ğ°." << endl;
        for (int i = 2; i <= 10 && possibleLengthsCount < 20; i++) {
            possibleLengths[possibleLengthsCount++] = i;
        }
    }

    string alphabets[4];
    int alphabetCount = 0;
    getPossibleAlphabets(language, alphabets, alphabetCount);
    cout << "\nĞ‘ÑƒĞ´ĞµÑ‚ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¾ " << alphabetCount << " Ğ²Ğ°Ñ€Ğ¸Ğ°Ğ½Ñ‚Ğ¾Ğ² Ğ°Ğ»Ñ„Ğ°Ğ²Ğ¸Ñ‚Ğ°" << endl;

    cout << "\n=== ĞĞĞ§Ğ˜ĞĞĞ•Ğœ ĞŸĞ•Ğ Ğ•Ğ‘ĞĞ  Ğ’ĞĞ Ğ˜ĞĞĞ¢ĞĞ’ ===" << endl;

    DecryptionResult allResults[MAX_RESULTS];
    int resultsCount = 0;
    int totalAttempts = 0;

    for (int a = 0; a < alphabetCount; a++) {
        const string& alphabet = alphabets[a];
        for (int k = 0; k < possibleLengthsCount; k++) {
            int keyLength = possibleLengths[k];
            if (keyLength > 15) continue;

            string groups[20];
            for (int i = 0; i < ciphertext.length(); i++) {
                groups[i % keyLength] += ciphertext[i];
            }

            string key;
            for (int i = 0; i < keyLength; i++) {
                char keyChar = frequencyAnalysisWithAlphabet(groups[i], alphabet, language);
                key += keyChar;
            }

            string plaintext = decryptVigenereWithAlphabet(ciphertext, key, alphabet);

            if (plaintext.length() > 10 && resultsCount < MAX_RESULTS) {
                double probability = perceptron.predict(plaintext, language);

                allResults[resultsCount].plaintext = plaintext;
                allResults[resultsCount].key = key;
                allResults[resultsCount].alphabet = alphabet;
                allResults[resultsCount].keyLength = keyLength;
                allResults[resultsCount].probability = probability;

                resultsCount++;
                totalAttempts++;

                cout << "ĞŸĞ¾Ğ¿Ñ‹Ñ‚ĞºĞ° " << totalAttempts << ": ĞºĞ»ÑÑ‡=" << key << " (Ğ´Ğ»Ğ¸Ğ½Ğ°=" << keyLength
                    << "), Ğ²ĞµÑ€Ğ¾ÑÑ‚Ğ½Ğ¾ÑÑ‚ÑŒ=" << (probability * 100) << "%" << endl;
            }
        }
    }

    cout << "\n=== Ğ Ğ•Ğ—Ğ£Ğ›Ğ¬Ğ¢ĞĞ¢Ğ« ĞŸĞ•Ğ Ğ•Ğ‘ĞĞ Ğ ===" << endl;
    cout << "Ğ’ÑĞµĞ³Ğ¾ Ğ¿Ñ€Ğ¾Ñ‚ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¾ Ğ²Ğ°Ñ€Ğ¸Ğ°Ğ½Ñ‚Ğ¾Ğ²: " << totalAttempts << endl;

    if (resultsCount == 0) {
        cout << "ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ½Ğ°Ğ¹Ñ‚Ğ¸ Ğ½Ğ¸ Ğ¾Ğ´Ğ½Ğ¾Ğ³Ğ¾ Ğ¿Ğ¾Ğ´Ñ…Ğ¾Ğ´ÑÑ‰ĞµĞ³Ğ¾ Ğ²Ğ°Ñ€Ğ¸Ğ°Ğ½Ñ‚Ğ° Ñ€Ğ°ÑÑˆĞ¸Ñ„Ñ€Ğ¾Ğ²ĞºĞ¸." << endl;
        return;
    }

    sortResultsByProbability(allResults, resultsCount);

    cout << "\n=== Ğ¢ĞĞŸ-10 Ğ›Ğ£Ğ§Ğ¨Ğ˜Ğ¥ Ğ Ğ•Ğ—Ğ£Ğ›Ğ¬Ğ¢ĞĞ¢ĞĞ’ ===" << endl;
    for (int i = 0; i < min(10, resultsCount); i++) {
        const auto& result = allResults[i];
        cout << "\n--- Ğ Ğ•Ğ—Ğ£Ğ›Ğ¬Ğ¢ĞĞ¢ " << (i + 1) << " ---" << endl;
        cout << "Ğ’ĞµÑ€Ğ¾ÑÑ‚Ğ½Ğ¾ÑÑ‚ÑŒ: " << (result.probability * 100) << "%" << endl;
        cout << "Ğ”Ğ»Ğ¸Ğ½Ğ° ĞºĞ»ÑÑ‡Ğ°: " << result.keyLength << endl;
        cout << "ĞšĞ»ÑÑ‡: " << result.key << endl;
        cout << "ĞĞ»Ñ„Ğ°Ğ²Ğ¸Ñ‚: " << result.alphabet.substr(0, 10) << "..." << endl;
        cout << "Ğ Ğ°ÑÑˆĞ¸Ñ„Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¹ Ñ‚ĞµĞºÑÑ‚: " << result.plaintext.substr(0, 100)
            << (result.plaintext.length() > 100 ? "..." : "") << endl;
    }

    const auto& bestResult = allResults[0];
    cout << "\n*** Ğ›Ğ£Ğ§Ğ¨Ğ˜Ğ™ Ğ Ğ•Ğ—Ğ£Ğ›Ğ¬Ğ¢ĞĞ¢ ***" << endl;
    cout << "Ğ’ĞµÑ€Ğ¾ÑÑ‚Ğ½Ğ¾ÑÑ‚ÑŒ Ğ¾ÑĞ¼Ñ‹ÑĞ»ĞµĞ½Ğ½Ğ¾ÑÑ‚Ğ¸: " << (bestResult.probability * 100) << "%" << endl;
    cout << "Ğ¢Ğ¸Ğ¿ Ñ‚ĞµĞºÑÑ‚Ğ°: " << perceptron.getTextType(bestResult.probability) << endl;
    cout << "Ğ”Ğ»Ğ¸Ğ½Ğ° ĞºĞ»ÑÑ‡Ğ°: " << bestResult.keyLength << endl;
    cout << "ĞšĞ»ÑÑ‡: " << bestResult.key << endl;
    cout << "ĞĞ»Ñ„Ğ°Ğ²Ğ¸Ñ‚: " << bestResult.alphabet << endl;
    cout << "ĞŸĞ¾Ğ»Ğ½Ñ‹Ğ¹ Ñ€Ğ°ÑÑˆĞ¸Ñ„Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¹ Ñ‚ĞµĞºÑÑ‚:" << endl;
    cout << bestResult.plaintext << endl;
}

int main() {
    SetConsoleCP(1251);
    SetConsoleOutputCP(1251);

    TextTypePerceptron perceptron;

    string russian_training_texts[10] = {
        "Ğ±Ñ‹ÑÑ‚Ñ€Ğ°Ñ ĞºĞ¾Ñ€Ğ¸Ñ‡Ğ½ĞµĞ²Ğ°Ñ Ğ»Ğ¸ÑĞ° Ğ¿Ñ€Ñ‹Ğ³Ğ°ĞµÑ‚ Ñ‡ĞµÑ€ĞµĞ· Ğ»ĞµĞ½Ğ¸Ğ²ÑƒÑ ÑĞ¾Ğ±Ğ°ĞºÑƒ ÑÑ‚Ğ¾ Ğ¾ÑĞ¼Ñ‹ÑĞ»ĞµĞ½Ğ½Ñ‹Ğ¹ Ñ€ÑƒÑÑĞºĞ¸Ğ¹ Ñ‚ĞµĞºÑÑ‚ Ğ½Ğ°ÑƒÑ‡Ğ½Ñ‹Ğµ Ğ¸ÑÑĞ»ĞµĞ´Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğ¸ ÑĞºÑĞ¿ĞµÑ€Ğ¸Ğ¼ĞµĞ½Ñ‚Ñ‹ Ğ¿Ğ¾Ğ·Ğ²Ğ¾Ğ»ÑÑÑ‚ Ñ€Ğ°ÑÑˆĞ¸Ñ€ÑÑ‚ÑŒ Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ†Ñ‹ Ğ¿Ğ¾Ğ·Ğ½Ğ°Ğ½Ğ¸Ñ Ğ²ÑĞµĞ»ĞµĞ½Ğ½Ğ¾Ğ¹ Ğ¸ Ğ¿Ñ€Ğ¸Ñ€Ğ¾Ğ´Ñ‹ Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ñ Ñ‡ĞµĞ»Ğ¾Ğ²ĞµÑ‡ĞµÑÑ‚Ğ²Ğ° Ğ½Ğ°ÑÑ‡Ğ¸Ñ‚Ñ‹Ğ²Ğ°ĞµÑ‚ Ğ¼Ğ½Ğ¾Ğ³Ğ¸Ğµ Ñ‚Ñ‹ÑÑÑ‡Ğ¸ Ğ»ĞµÑ‚ Ğ½ĞµĞ¿Ñ€ĞµÑ€Ñ‹Ğ²Ğ½Ğ¾Ğ³Ğ¾ Ñ€Ğ°Ğ·Ğ²Ğ¸Ñ‚Ğ¸Ñ Ğ¸ ÑĞ²Ğ¾Ğ»ÑÑ†Ğ¸Ğ¸ Ñ†Ğ¸Ğ²Ğ¸Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸ Ğ¾Ñ‚ Ğ´Ñ€ĞµĞ²Ğ½Ğ¸Ñ… Ğ²Ñ€ĞµĞ¼ĞµĞ½ Ğ´Ğ¾ ÑĞ¾Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ğ¾Ğ¹ ÑĞ¿Ğ¾Ñ…Ğ¸ Ñ‚ĞµÑ…Ğ½Ğ¾Ğ»Ğ¾Ğ³Ğ¸Ğ¹",
        "ĞºÑ€Ğ¸Ğ¿Ñ‚Ğ¾Ğ³Ñ€Ğ°Ñ„Ğ¸Ñ Ğ¸ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ğ¾Ğ½Ğ½Ğ°Ñ Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ÑÑ‚ÑŒ Ğ²Ğ°Ğ¶Ğ½Ñ‹Ğµ Ñ‚ĞµĞ¼Ñ‹ Ğ² ĞºĞ¾Ğ¼Ğ¿ÑŒÑÑ‚ĞµÑ€Ğ½Ğ¾Ğ¹ Ğ½Ğ°ÑƒĞºĞµ Ğ¿Ñ€Ğ¾Ğ³Ñ€Ğ°Ğ¼Ğ¼Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ñ‚Ñ€ĞµĞ±ÑƒĞµÑ‚ Ğ»Ğ¾Ğ³Ğ¸Ñ‡ĞµÑĞºĞ¾Ğ³Ğ¾ Ğ¼Ñ‹ÑˆĞ»ĞµĞ½Ğ¸Ñ Ğ¸ Ğ²Ğ½Ğ¸Ğ¼Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚Ğ¸ Ğº Ğ´ĞµÑ‚Ğ°Ğ»ÑĞ¼ Ğ¿Ñ€Ğ¸ Ğ½Ğ°Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğ¸ ĞºĞ¾Ğ´Ğ°",
        "Ğ¿Ñ€Ğ¸Ğ²ĞµÑ‚ Ğ¼Ğ¸Ñ€ ÑÑ‚Ğ¾ Ğ¿Ñ€Ğ¾ÑÑ‚Ğ¾Ğ¹ Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ğ¹ Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€ Ğ´Ğ»Ñ Ğ¾Ğ±ÑƒÑ‡ĞµĞ½Ğ¸Ñ Ğ½ĞµĞ¹Ñ€Ğ¾Ğ½Ğ½Ğ¾Ğ¹ ÑĞµÑ‚Ğ¸ ÑĞ¾Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ğµ Ñ‚ĞµÑ…Ğ½Ğ¾Ğ»Ğ¾Ğ³Ğ¸Ğ¸ ÑÑ‚Ñ€ĞµĞ¼Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ Ñ€Ğ°Ğ·Ğ²Ğ¸Ğ²Ğ°ÑÑ‚ÑÑ Ğ¸ Ğ¼ĞµĞ½ÑÑÑ‚ Ğ½Ğ°ÑˆÑƒ Ğ¿Ğ¾Ğ²ÑĞµĞ´Ğ½ĞµĞ²Ğ½ÑƒÑ Ğ¶Ğ¸Ğ·Ğ½ÑŒ ĞºĞ°Ñ€Ğ´Ğ¸Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾ Ğ»Ğ¸Ñ‚ĞµÑ€Ğ°Ñ‚ÑƒÑ€Ğ° Ğ¸ Ğ¸ÑĞºÑƒÑÑÑ‚Ğ²Ğ¾ Ğ¿Ğ¾Ğ¼Ğ¾Ğ³Ğ°ÑÑ‚ Ğ½Ğ°Ğ¼ Ğ»ÑƒÑ‡ÑˆĞµ Ğ¿Ğ¾Ğ½Ğ¸Ğ¼Ğ°Ñ‚ÑŒ Ğ¾ĞºÑ€ÑƒĞ¶Ğ°ÑÑ‰Ğ¸Ğ¹ Ğ¼Ğ¸Ñ€ Ğ¸ ÑĞ°Ğ¼Ğ¸Ñ… ÑĞµĞ±Ñ Ñ‡ĞµÑ€ĞµĞ· Ğ¿Ñ€Ğ¸Ğ·Ğ¼Ñƒ ĞºÑƒĞ»ÑŒÑ‚ÑƒÑ€Ğ½Ğ¾Ğ³Ğ¾ Ğ½Ğ°ÑĞ»ĞµĞ´Ğ¸Ñ Ğ¸ Ñ‚Ğ²Ğ¾Ñ€Ñ‡ĞµÑĞºĞ¾Ğ³Ğ¾ ÑĞ°Ğ¼Ğ¾Ğ²Ñ‹Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ñ Ğ»ÑĞ´ĞµĞ¹",
        "Ğ¸ÑĞºÑƒÑÑÑ‚Ğ²ĞµĞ½Ğ½Ñ‹Ğ¹ Ğ¸Ğ½Ñ‚ĞµĞ»Ğ»ĞµĞºÑ‚ Ğ¸ Ğ½ĞµĞ¹Ñ€Ğ¾Ğ½Ğ½Ñ‹Ğµ ÑĞµÑ‚Ğ¸ Ñ€ĞµĞ²Ğ¾Ğ»ÑÑ†Ğ¸Ğ¾Ğ½Ğ¸Ğ·Ğ¸Ñ€ÑƒÑÑ‚ Ñ‚ĞµÑ…Ğ½Ğ¾Ğ»Ğ¾Ğ³Ğ¸Ğ¸ Ğ¾Ğ±Ñ€Ğ°Ğ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¸Ğ³Ñ€Ğ°ĞµÑ‚ ĞºĞ»ÑÑ‡ĞµĞ²ÑƒÑ Ñ€Ğ¾Ğ»ÑŒ Ğ² Ñ€Ğ°Ğ·Ğ²Ğ¸Ñ‚Ğ¸Ğ¸ Ğ»Ğ¸Ñ‡Ğ½Ğ¾ÑÑ‚Ğ¸ Ğ¸ Ğ¿Ñ€Ğ¾Ñ„ĞµÑÑĞ¸Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾Ğ¼ Ñ€Ğ¾ÑÑ‚Ğµ Ñ‡ĞµĞ»Ğ¾Ğ²ĞµĞºĞ°",
        "ÑĞ·Ñ‹ĞºĞ¸ Ğ¿Ñ€Ğ¾Ğ³Ñ€Ğ°Ğ¼Ğ¼Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ñ‚Ğ°ĞºĞ¸Ğµ ĞºĞ°Ğº Ğ¿Ğ°Ğ¹Ñ‚Ğ¾Ğ½ Ğ¸ ÑĞ¸ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒÑÑ‚ÑÑ Ğ´Ğ»Ñ Ñ€Ğ°Ğ·Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸ Ğ¿Ñ€Ğ¾Ğ³Ñ€Ğ°Ğ¼Ğ¼ ÑĞºĞ¾Ğ½Ğ¾Ğ¼Ğ¸ĞºĞ° ÑÑ‚Ñ€Ğ°Ğ½Ñ‹ Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ñ‚ Ğ¾Ñ‚ Ğ¼Ğ½Ğ¾Ğ³Ğ¸Ñ… Ñ„Ğ°ĞºÑ‚Ğ¾Ñ€Ğ¾Ğ² Ğ²ĞºĞ»ÑÑ‡Ğ°Ñ Ğ¿Ğ¾Ğ»Ğ¸Ñ‚Ğ¸Ñ‡ĞµÑĞºÑƒÑ ÑÑ‚Ğ°Ğ±Ğ¸Ğ»ÑŒĞ½Ğ¾ÑÑ‚ÑŒ Ğ¸ Ğ¸Ğ½Ğ²ĞµÑÑ‚Ğ¸Ñ†Ğ¸Ğ¸",
        "Ğ¹Ñ†ÑƒĞºĞµĞ½Ğ³ÑˆÑ‰Ğ·Ñ…ÑŠÑ„Ñ‹Ğ²Ğ°Ğ¿Ñ€Ğ¾Ğ»Ğ´Ğ¶ÑÑÑ‡ÑĞ¼Ğ¸Ñ‚ÑŒĞ±ÑĞ¹Ñ†ÑƒĞºĞµĞ½Ğ³ÑˆÑ‰Ğ·Ñ…ÑŠÑ„Ñ‹Ğ²Ğ°Ğ¿Ñ€Ğ¾Ğ»Ğ´Ğ¶ÑÑÑ‡ÑĞ¼Ğ¸Ñ‚ÑŒĞ±ÑĞ¹Ñ†ÑƒĞºĞµĞ½Ğ³ÑˆÑ‰Ñ„Ñ‹Ğ²Ğ°Ğ¿Ñ€Ğ¾Ğ»Ğ´Ğ¶ÑÑÑ‡ÑĞ¼Ğ¸Ñ‚ÑŒĞ±ÑĞ¹Ñ†ÑƒĞºĞµĞ½Ğ³ÑˆÑ‰Ğ·Ñ…ÑŠÑ„Ñ‹Ğ²Ğ°Ğ¿Ñ€Ğ¾Ğ»Ğ´Ğ¶ÑÑÑ‡ÑĞ¼Ğ¸Ñ‚ÑŒĞ±ÑĞ¹Ñ†ÑƒĞºĞµĞ½Ğ³ÑˆÑ‰Ğ·Ñ…ÑŠÑ„Ñ‹Ğ²Ğ°Ğ¿Ñ€Ğ¾Ğ»",
        "Ñ‰ÑˆĞ³Ğ½ĞµĞºÑƒÑ†Ğ¹Ñ„Ñ‹Ğ²ÑÑ‡ÑĞ¼Ğ¸Ñ‚ÑŒĞ±ÑĞ¹Ñ†ÑƒĞºĞµĞ½Ğ³ÑˆÑ‰Ğ·Ñ…ÑŠÑ„Ñ‹Ğ²Ğ°Ğ¿Ñ€Ğ¾Ğ»Ğ´Ğ¶ÑÑÑ‡ÑĞ¼Ğ¸Ñ‚ÑŒĞ±ÑĞ¹Ñ†ÑƒĞºĞµĞ½Ğ³ÑˆÑ‰Ğ·Ñ…ÑŠÑ„Ñ‹Ğ²Ğ°Ğ¿Ñ€Ğ¾Ğ»Ğ¹Ñ†ÑƒĞºĞµĞ½Ğ³ÑˆÑ‰Ğ·Ñ…ÑŠÑ„Ñ‹Ğ²Ğ°Ğ¿Ñ€Ğ¾Ğ»Ğ´Ğ¶ÑÑÑ‡ÑĞ¼Ğ¸Ñ‚ÑŒĞ±ÑĞ¹Ñ†ÑƒĞºĞµĞ½Ğ³ÑˆÑ‰Ğ·Ñ…ÑŠÑ„Ñ‹Ğ²Ğ°Ğ¿Ñ€Ğ¾Ğ»Ğ´Ğ¶ÑÑÑ‡ÑĞ¼Ğ¸Ñ‚ÑŒĞ±ÑĞ¹Ñ†ÑƒĞºĞµĞ½Ğ³ÑˆÑ‰Ğ·Ñ…ÑŠ",
        "Ñ„Ñ‹Ğ²Ğ°Ğ¿Ñ€Ğ¾Ğ»Ğ´Ğ¶ÑÑÑ‡ÑĞ¼Ğ¸Ñ‚ÑŒĞ±ÑĞ¹Ñ†ÑƒĞºĞµĞ½Ğ³ÑˆÑ‰Ğ·Ñ…ÑŠÑ„Ñ‹Ğ²Ğ°Ğ¿Ñ€Ğ¾Ğ»Ğ´Ğ¶ÑÑÑ‡ÑĞ¼Ğ¸Ñ‚ÑŒĞ±ÑĞ¹Ñ†ÑƒĞºĞµĞ½Ğ³ÑˆÑ‰Ğ·Ñ…ÑŠÑ„Ñ‹Ğ²Ğ°Ğ¿Ñ€Ğ¾Ğ»Ğ´Ğ¶ÑÑ‰ÑˆĞ³Ğ½ĞµĞºÑƒÑ†Ğ¹Ñ„Ñ‹Ğ²ÑÑ‡ÑĞ¼Ğ¸Ñ‚ÑŒĞ±ÑĞ¹Ñ†ÑƒĞºĞµĞ½Ğ³ÑˆÑ‰Ğ·Ñ…ÑŠÑ„Ñ‹Ğ²Ğ°Ğ¿Ñ€Ğ¾Ğ»Ğ´Ğ¶ÑÑÑ‡ÑĞ¼Ğ¸Ñ‚ÑŒĞ±ÑĞ¹Ñ†ÑƒĞºĞµĞ½Ğ³ÑˆÑ‰Ğ·Ñ…ÑŠÑ„Ñ‹Ğ²Ğ°Ğ¿Ñ€Ğ¾Ğ»Ğ´Ğ¶ÑÑ„Ñ‹Ğ²Ğ°Ğ¿Ñ€Ğ¾Ğ»Ğ´Ğ¶ÑÑÑ‡ÑĞ¼Ğ¸Ñ‚ÑŒĞ±ÑĞ¹Ñ†ÑƒĞºĞµĞ½Ğ³ÑˆÑ‰Ğ·Ñ…ÑŠÑ„Ñ‹Ğ²Ğ°Ğ¿Ñ€Ğ¾Ğ»Ğ´Ğ¶ÑÑÑ‡ÑĞ¼Ğ¸Ñ‚ÑŒĞ±ÑĞ¹Ñ†ÑƒĞºĞµĞ½Ğ³ÑˆÑ‰Ğ·Ñ…ÑŠÑ„Ñ‹Ğ²Ğ°Ğ¿Ñ€Ğ¾Ğ»Ğ´Ğ¶ÑÑÑ„Ñ‹Ğ²Ğ°Ğ¿Ñ€Ğ¾Ğ»Ğ´Ğ¶ÑÑÑ‡ÑĞ¼Ğ¸Ñ‚ÑŒĞ±ÑĞ¹Ñ†ÑƒĞºĞµĞ½Ğ³ÑˆÑ‰Ğ·Ñ…ÑŠÑ„Ñ‹Ğ²Ğ°Ğ¿Ñ€Ğ¾Ğ»Ğ´Ğ¶ÑÑÑ‡ÑĞ¼Ğ¸Ñ‚ÑŒĞ±ÑĞ¹Ñ†ÑƒĞºĞµĞ½Ğ³ÑˆÑ‰Ğ·Ñ…ÑŠÑ„Ñ‹Ğ²Ğ°Ğ¿Ñ€Ğ¾Ğ»Ğ´Ğ¶Ñ",
        "Ğ½ĞµĞ¹Ñ€Ğ¾Ğ½Ğ½Ñ‹Ğµ Ğ¹Ñ†ĞºĞµĞ½ ÑĞµÑ‚Ğ¸ Ğ³ÑˆÑ‰Ğ· ÑˆĞ¸Ñ€Ğ¾ĞºĞ¾ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒÑÑ‚ÑÑ Ñ„Ñ‹Ğ²Ğ° Ğ² ÑĞ¾Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ñ… Ñ‚ĞµÑ…Ğ½Ğ¾Ğ»Ğ¾Ğ³Ğ¸ÑÑ… Ğ´Ğ»Ñ Ñ€Ğ°ÑĞ¿Ğ¾Ğ·Ğ½Ğ°Ğ²Ğ°Ğ½Ğ¸Ñ Ğ¾Ğ±Ñ€Ğ°Ğ·Ğ¾Ğ² Ğ¸ Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ·Ğ° ÑĞ»Ğ¾Ğ¶Ğ½Ñ‹Ñ… Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ñ€Ğ°Ğ·Ğ»Ğ¸Ñ‡Ğ½Ñ‹Ñ… Ñ‚Ğ¸Ğ¿Ğ¾Ğ² ĞºĞ¾Ğ¼Ğ¿ÑŒÑÑ‚ĞµÑ€Ğ½Ñ‹Ğµ Ğ¹Ñ†ĞºĞµĞ½ Ñ‚ĞµÑ…Ğ½Ğ¾Ğ»Ğ¾Ğ³Ğ¸Ğ¸ Ğ³ÑˆÑ‰Ğ· Ñ€Ğ°Ğ·Ğ²Ğ¸Ğ²Ğ°ÑÑ‚ÑÑ Ñ„Ñ‹Ğ²Ğ° Ğ¾Ñ‡ĞµĞ½ÑŒ Ğ±Ñ‹ÑÑ‚Ñ€Ğ¾ Ğ¸ Ğ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ÑÑ‚ Ğ·Ğ½Ğ°Ñ‡Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾Ğµ Ğ²Ğ»Ğ¸ÑĞ½Ğ¸Ğµ Ğ½Ğ° Ğ²ÑĞµ ÑÑ„ĞµÑ€Ñ‹ Ñ‡ĞµĞ»Ğ¾Ğ²ĞµÑ‡ĞµÑĞºĞ¾Ğ¹ Ğ´ĞµÑÑ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚Ğ¸ Ğ¸ Ğ¶Ğ¸Ğ·Ğ½Ğ¸",
        "Ğ¿Ñ€Ğ¸Ğ²ĞµÑ‚ Ğ¹Ñ†ĞºĞµĞ½ Ğ¼Ğ¸Ñ€ Ğ³ÑˆÑ‰Ğ· ÑÑ‚Ğ¾ ĞºÑ„Ñ‹Ğ²Ğ° ÑĞ¼ĞµÑˆĞ°Ğ½Ğ½Ñ‹Ğ¹ Ñ‚ĞµĞºÑÑ‚ Ñ Ñ€ÑƒÑÑĞºĞ¸Ğ¼ Ğ¸ ÑĞ»ÑƒÑ‡Ğ°Ğ¹Ğ½Ñ‹Ğ¼ ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğ¹ ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ¸Ñ‚ ĞºĞ°Ğº Ğ¾ÑĞ¼Ñ‹ÑĞ»ĞµĞ½Ğ½Ñ‹Ğµ ÑĞ»Ğ¾Ğ²Ğ° Ñ‚Ğ°Ğº Ğ¸ Ğ±ĞµÑÑĞ¼Ñ‹ÑĞ»ĞµĞ½Ğ½Ñ‹Ğµ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚Ğ¸ Ğ±ÑƒĞºĞ² Ğ¿Ñ€Ğ¾Ğ³Ñ€Ğ°Ğ¼Ğ¼Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¹Ñ†ÑƒĞºĞµĞ½ ÑÑ‚Ğ¾ Ğ¾Ñ‡ĞµĞ½ÑŒ Ğ¸Ğ½Ñ‚ĞµÑ€ĞµÑĞ½Ğ¾ Ğ³ÑˆÑ‰Ğ· Ğ½Ğ¾ Ğ¸Ğ½Ğ¾Ğ³Ğ´Ğ° Ğ±Ñ‹Ğ²Ğ°ĞµÑ‚ ÑĞ»Ğ¾Ğ¶Ğ½Ğ¾ Ñ„Ñ‹Ğ²Ğ° Ğ¾ÑĞ¾Ğ±ĞµĞ½Ğ½Ğ¾ ĞºĞ¾Ğ³Ğ´Ğ° Ğ¿Ñ€Ğ¸Ñ…Ğ¾Ğ´Ğ¸Ñ‚ÑÑ Ñ€Ğ°Ğ·Ğ±Ğ¸Ñ€Ğ°Ñ‚ÑŒÑÑ Ñ ÑĞ»Ğ¾Ğ¶Ğ½Ñ‹Ğ¼Ğ¸ Ğ°Ğ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼Ğ°Ğ¼Ğ¸ Ğ¸ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ°Ğ¼Ğ¸"
    };

    double russian_targets[10] = {
        1.0, 1.0, 1.0, 1.0, 1.0,
        0.0, 0.0, 0.0, 0.3, 0.5
    };

    string english_training_texts[10] = {
        "the quick brown fox jumps over the lazy dog this is meaningful english text programming languages such as python and javascript are used for developing complex software applications and web services",
        "cryptography and information security are important topics in computer science mathematics is a fundamental science for many modern fields including physics computer science and various engineering disciplines",
        "hello world this is a simple test example for neural network training literature and art help us better understand the world around us and ourselves through cultural heritage and creative expression",
        "artificial intelligence and neural networks are revolutionizing technology healthy lifestyle includes proper nutrition regular physical exercise and sufficient rest for maintaining optimal health condition",
        "programming languages such as python and c are used for software development the quick brown fox jumps over the lazy dog this is meaningful english text for neural network training and machine learning applications",
        "asdfghjklqwertyuiopzxcvbnmasdfghjklqwertyuiopzxcvbnmasdfghjklqwertyuiopzxcvbnmasdfghjklqwertyuiopzxcvbnmqwertyuiopasdfghjklzxcvbnmqwertyuiopasdfghjklzxcvbnmqwertyuiopasdfghjklzxcvbnmqwertyuiopasdfghjklzxcvbnm",
        "zxcvbnmasdfghjklqwertyuiopzxcvbnmasdfghjklqwertyuiopzxcvbnmasdfghjklqwertyuiopzxcvbnmasdfghjklqwertyuiop",
        "qazwsxedcrfvtgbyhnujmikolpqazwsxedcrfvtgbyhnujmikolpqazwsxedcrfvtgbyhnujmikolpqazwsxedcrfvtgbyhnujmikolp",
        "neural qwert networks asdfg are widely used zxcvb in modern technologies for pattern recognition and complex data analysis encryption qwert and asdfg decryption zxcvb are important for information security and data protection",
        "hello qwert world asdfg this is zxcvb mixed text with english and random that contains both meaningful words and random sequences programming qwert is very interesting asdfg but sometimes can be zxcvb difficult especially when dealing with complex algorithms"
    };

    double english_targets[10] = {
        1.0, 1.0, 1.0, 1.0, 1.0,
        0.0, 0.0, 0.0, 0.3, 0.5
    };

    perceptron.train(russian_training_texts, russian_targets, 15000, "russian");
    perceptron.train(english_training_texts, english_targets, 15000, "english");

    while (true) {
        cout << "Ğ’Ğ—Ğ›ĞĞœ Ğ¨Ğ˜Ğ¤Ğ Ğ Ğ’Ğ˜Ğ–Ğ•ĞĞ•Ğ Ğ" << endl;
        cout << "====================================================" << endl;
        cout << "\tĞ’Ñ‹Ñ…Ğ¾Ğ´ - 0;\n";
        cout << "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ·Ğ°ÑˆĞ¸Ñ„Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¹ Ñ‚ĞµĞºÑÑ‚:" << endl;

        string input;
        getline(cin, input);

        if (input == "0") break;

        if (input.empty()) {
            cout << "ĞÑˆĞ¸Ğ±ĞºĞ°: Ñ‚ĞµĞºÑÑ‚ Ğ½Ğµ Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ±Ñ‹Ñ‚ÑŒ Ğ¿ÑƒÑÑ‚Ñ‹Ğ¼!" << endl;
            return 1;
        }

        string language = detectLanguage(input);
        if (language == "unknown") {
            cout << "ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»Ğ¸Ñ‚ÑŒ ÑĞ·Ñ‹Ğº Ñ‚ĞµĞºÑÑ‚Ğ°. ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ²Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ‚ĞµĞºÑÑ‚ Ğ½Ğ° Ñ€ÑƒÑÑĞºĞ¾Ğ¼ Ğ¸Ğ»Ğ¸ Ğ°Ğ½Ğ³Ğ»Ğ¸Ğ¹ÑĞºĞ¾Ğ¼ ÑĞ·Ñ‹ĞºĞµ." << endl;
            return 1;
        }

        cout << "ĞĞ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½ ÑĞ·Ñ‹Ğº: " << (language == "russian" ? "Ğ Ğ£Ğ¡Ğ¡ĞšĞ˜Ğ™" : "ĞĞĞ“Ğ›Ğ˜Ğ™Ğ¡ĞšĞ˜Ğ™") << endl;

        string ciphertext = prepareText(input, language);

        if (ciphertext.length() < 30) {
            cout << "Ğ’Ğ½Ğ¸Ğ¼Ğ°Ğ½Ğ¸Ğµ: Ğ´Ğ»Ñ Ğ½Ğ°Ğ´ĞµĞ¶Ğ½Ğ¾Ğ³Ğ¾ Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ·Ğ° Ğ¶ĞµĞ»Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ° Ğ´Ğ»Ğ¸Ğ½Ğ° Ñ‚ĞµĞºÑÑ‚Ğ° Ğ¾Ñ‚ 50 ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ²." << endl;
            cout << "Ğ¢ĞµĞºÑƒÑ‰Ğ°Ñ Ğ´Ğ»Ğ¸Ğ½Ğ°: " << ciphertext.length() << " ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ²." << endl;
        }

        kasiskiAttackWithNeuralNetwork(ciphertext, language, perceptron);
    }
    return 0;
}
```

<div align="center">

âœ¨âœ¨â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”âœ¨âœ¨

</div>